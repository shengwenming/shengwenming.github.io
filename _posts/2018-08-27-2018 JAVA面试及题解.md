---
layout:     post
title:      JAVA面试及题解
subtitle:
date:       2018-08-25
author:     SWM
header-img: img/back.jpg
catalog: true
tags:
    - JAVA
    

---
#基础篇

##基本功

###    1、面向对象的特征
    面向对象的三个基本特征是封装、多态和继承。
    
    **封装**就是把事物抽象成类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    
    **继承**可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
    继承实现的三种方式为：实现继承、接口继承和可视继承。
    实现继承是指使用基类的属性和方法而无需额外编码的能力
    接口继承是指仅使用属性和方法名称，但是子类必须提供实现的能力
    可视继承是指子（窗体）类使用基（窗体）类的外观和实现代码的能力。
    
###    2、final、finally、finalize 的区别

    final是修饰符，可以修饰类、成员方法和变量。
    
    修饰类：该类不能被继承
    修饰方法：该方法不能被重写
    修饰变量：该变量是常量
    
    
    finally
    
    是异常处理的一部分，常用于释放资源
    一般来说，finally中的方法一定会被执行。在特殊情况下：在执行finally之前，jvm退出了，
    该方法不能被执行
    
    
    finallize
    
    是Object类的一个方法，用于垃圾回收
    
### 3、int和Integer的区别

    Integer是int的包装类型，int是基本的数据类型
    Integer变量必须实例化之后才能使用而int不用
    Integer是实际对象的引用，指向此new的Integer对象；int直接存储数据值
    Integer的默认值是null；int的默认值是0
    
### 4、重载和重写的区别
    重载是让类以统一方式处理不同类型数据的一种手段，他们具有相同的名字，但具有不同参数个数\类型
    1、参数个数、类型、顺序至少有一个不同
    2、不能重载只有返回值不同的方法名
    3、存在于父类和子类、同类中
    
    重写：
    1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载
    2、返回的类型必须一直与被重写的方法返回类型相同，否则不能称其为重写而是重载
    3、访问修饰符的限制一定要大于 被重写方法的访问修饰符（public > protected > default > private ）
    4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
    
### 5、接口和抽象类的区别

    1、接口和抽象类都不能被直接实例化，如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象
    这个子类继承了这个抽象类的所有抽象方法，如果接口要实例化，那么接口定义的变量指向一个子类对象，这个
    子类必须实现这个接口的所有方法
    
    2、抽象类要被子类继承，接口要被子类实现
    3、接口里面只能对方法进行声明，抽象类可以对方法进行声明也可以对方法进行实现
    4、抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类，接口里面
    的方法也必须全部被实现类实现，如果子类不能实现那么子类必须是抽象类。
    5、接口里面的方法只能声明，不能具体实现。这个说明接口时设计的结果，抽象类是重构的结果
    6、抽象类里面可以没有抽象方法。
    7、如果一个类里面有抽象方法那么这个类一定是抽象类。
    8、抽象类中的方法都要被实现，所以抽象方法不能使静态的static，也不能是private
    9、接口（类）可以继承接口，甚至可以继承多个接口。但类只能继承一个类。
    10、抽象级别从高到低：接口 > 抽象类 > 实现类。
    11、抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。当你关注事物本质的时候，请用抽象类
    当你关注操作的时候，请用接口
    12、抽象类的功能应该是远多于接口，但是定义抽象类的代价比较高。因为高级语言一个类只能继承一个父类，
    即在设计的时候要考虑到所有的这个类的子类共有的属性和方法；但是接口却可以继承多个接口，因此接口你只
    需要将特定的动作方法抽象到这个接口即可。也就是说接口的设计具有更大可扩展性，而抽象类设计必须十分
    谨慎
    
### 6、说说反射的用途及实现       
    反射机制就是JAVA在运行时的一项自观能力，通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。
    
    JAVA的反射机制的实现要借助于4个类：class 、Constructor、Field、Method
    
    JAVA反射的作用：
    在JAVA运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法，对于任意一个对象可以调用他的
    任意一个方法。
    这种动态获取类的信息以及动态调用对象的方法功能来自于java语言的反射机制
    
    Java反射机制主要提供了以下功能：
    在运行时判断任意一个对象所属的类
    在运行时构造任意一个类对象
    在运行时判断任意一个类所具有的成员变量和方法
    在运行时调用任意一个对象的方法
    
    
#### 7、说说自定义注解的场景及实现  
    跟踪代码的依赖性，实现待提配置文件的功能。比较常见的是Spring等框架中的基于注解配置。还可以生成文档
    常见的@See@param@return等。如@override放在方法签名，如果这个并不是覆盖了超类方法，则编译时就能
    检查出 。
    使用@inteface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成
    细节，在定义注解时，不能继承其他注解接口 
    
    
#### 8、HTTP 请求的 GET 与 POST 方式的区别  
    最直观的语义上的区别GET用于获取数据，POST用于提交数据
    GET的参数有长度限制（受限于URL长度，具体取决于浏览器和服务器），而POST则没有
    
#### 9、    session 与 cookie 区别
    1、session在服务端，cookie在客户端（浏览器）
    2、session默认被存在服务器的一个文件里
    3、session的运行以来session id 而 session id是存在cookie中的，也就是说，如果浏览器禁用了cookie，
    同时session也会失效（但是可通过其他方式实现，比如在URL中传递session id）
    4、session可以放在文件、数据库和内存中都可以
    5、用户验证场合一般会用session
    
    维持一个会话的核心就是客户端的唯一标识即session id


#### 10、session 分布式处理

       session复制：
       在支持session复制的web服务器上，通过修改web服务器的配置，可实现将session同步到其他web服务器
       达到每个web服务器上都保存一致的session
       优点：代码上不需要修改和支持
       缺点：需要依赖支持的web服务器，一旦更换成不支持的web服务器就不能使用了，在数据量很大的情况下，
       不仅占用网络资源，而且会导致延迟
       
       适用场景：只适用于web服务器比较少且session数据量小的情况
       可用场景：开原方案tomcat-redis-session-manager
       
       session粘滞：
       将用户的每次请求都通过某种方法强制分发到某一个web服务器上，只要这个服务器上存储了对应session数据，
       就可以实现会话跟踪
       
       优点：使用简单，没有额外开销
       缺点：一旦某个web服务器重启或宕机相对应的session数据将会丢失，而且需要依赖负载均衡机制
       
       使用场景：对稳定性要求不是很高的业务场景
       
       session集中管理：
       在单独的服务器或服务器集群上使用缓存技术，如Redis存储session数据，集中管理所有的session，所有的web
       服务器都从这个存储介质中存取对应的session，实现session共享
       优点：可靠性高，减少web服务器的资源开销
       缺点：实现上有些复杂，配置较多
       适用场景：web服务器较多，要求高可用的情况
       可用方案：Spring session 也可以自己实现，主要是重写
       
       基于cookie管理：
       这种方式每次发起请求的时候都需要将session数据存到cookie中传递给服务端
       优点：不需要依赖外部存储，不需要额外配置
       缺点：不安全。易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽
       适用场景：数据不重要、不敏感且数据量小
       
####  11、       JDBC 流程

    1、加载Driver类，注册数据库驱动
    2、通过DriverManager，适用URL,用户名，密码建立连接
    3、通过connection，适用sql语句打开statement对象
    4、执行语句将结果返回resultset
    5、对结果进行处理
    6、倒叙释放资源resultset - preparedstatement - connection
    



#### 12、MVC 设计思想
    MVC是软件架构的思想，将一个软件按照模型、视图、控制器进行划分，其中，模型用来封装业务逻辑，视图用来
    表示逻辑，控制器用来协调模型与视图（视图通过控制器来调用模型，模型返回处理结果也要先交给控制器，由
    控制器来选择合适的视图显示处理结果）。
    1、模型：
    业务逻辑包含了业务数据加工与处理以及相应的基础服务
    2、视图:展现模型处理结果，另外，提供相应的操作界面，方便用户使用
    3、控制器：视图发请求给控制器，由控制器来选择相应的模型来处理；模型返回的结果给控制器，由控制器选择
    合适视图
    
    1、使用MVC思想来设计一个软件，最根本的原因是为了实现模型的复用
    2、代码的维护性更好
    3、方便测试
    
    
    使用MVC，会增加代码量，相应的也会增加软件开发的成本，设计难度也会增加
    
    
#### 13、    equals 与 == 的区别

    1、==判断两个变量或者实例是不是指向一个内存空间
    equals是判断两个变脸或者实例所指向的内存空间的值是不是相同
    2、==指向内存地址进行比较，equals是对字符串的内容比较
    3、==指引用是否相同，equals指的是值是否相同
    
### 集合

#### 1、List 和 Set 和 Map 区别
        Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素
        （Elements）。一些collection允许相同元素，而另一些则不行
        所有实现Collection接口的类都必须提供两个标准的构造函数：无参的构造函数用于创建空的Collection
        有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的
        Collection有相同的元素。后一个构造函数允许用户复制一个Collection。
        不论Collection的实际类型如何，他都支持一个iterator（）的方法，该方法返回一个迭代子，使用迭代子
        即可逐一访问Collection的每一个元素。
        
        由Collection接口派生的两个接口是List和Set
        
        List接口：
        List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在
        List中的位置类似于数组下标）来访问List中的元素这类似于Java数组，List允许有相同的元素。
        实现List接口的常用类有LinkedList、ArrayList、Vector、Stack
        
            LinkedList类：实现了List接口，允许Null元素。此外LinkedList提供额外的get、remove、insert
            方法在LinkedList首部或尾部。
            这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。
            注意LinkedList没有同步方法。如果多线程同时访问一个List，必须自己实现访问同步，一种解决
            方法是在创建List时构造一个同步的List：
            List list = Collections.synchronizedList(new LinkedList());
            
            ArrayList类：ArrayList实现了可变大小的数组，它允许所有元素，包括null。ArrayList没有同步
            size、isempty、get、set方法运行时间为常数，但是add方法开销为分摊的常数，添加n各元素的时间
            复杂度为O(n)，其他方法运行时间为线性。
            每个ArrayList实例都有一个容量（Capacity）.即用于存储的数组的大小，这个容量可随着不断添加
            新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素的时候，在插入前可以调用
            ensureCapacity方法来增加ArrayList的容量以提高插入效率。ArrayList也是非同步的。
            
            Vector：Vector非常类似ArrayList,但是Vector是同步的，由Vector创建的Iterator，虽然和ArrayList
            创建的Iterator是同一接口，但是，因为vector是同步的，当一个Vector被创建而且正在被使用，
            另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出
            ConcurrentModificationException，因此必须捕获异常。
            
            Stack类：Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外是的Vector可以被当做
            堆栈所使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，
            search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。
        
        
        Set接口：
        存入set的每个元素必须是唯一的，set不保存重复元素。加入set的元素必须定义equals方法确保对象
        的唯一性。set的元素是无序的。
            HashSet：为快速查找设计的Set，存入HashSet的对象必须定义hashcode。
            TreeSet：保存次序的Set，底层为树结构，使用它可以从set中提取有序的xulie
            LingkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）
            于是在使用迭代器遍历Set时，结果会按插入次序显示。
            
        
        
              
              
        Map：     
            Map是一种映射的数据结构，存储key-value的数据，有put、get、containskey、containsvalue等。
            标准的Java类库中包含了几种不同的Map：HashMap，TreeMap，LinkedHashMap、WeakHashMap、
            IdentityHashMap，它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“
            键“等价的策略不同
            
            
            HashTable：
            HashTable实现Map接口，任何非空（non-null）的对象都可作为key或者value。HashTable是同步的
            （线程安全）
            
            HashMap：
            HashMap实现Map接口，是非同步的，HashMap允许null，即null value和null key。HashSet就是基于
            HashMap，只使用了HashMap的key作为单个元素存储。
            
            HashMap的访问方式是基于Map的最基础的三种方式，HashMap的存储方式为散列表（哈希表），哈希表
            使用数组加链表的组合的方式进行存储。
            put的过程：
            1、插入第一个元素的时候，需要先初始化数组大小
            2、如果key为null会把这个放到table[0]
            3、求key的hash值
            4、获取对应的数组下标
            5、遍历下标处的链表，看是否有重复的key已经存在，如果有，则直接覆盖，put方法返回旧值
            6、不存在重复的key，将此entry添加到链表中
            
            
            数组初始化：
            当第一个元素插入HashMap的时候做一次数组初始化，就是先确定初始的数组大小，并计算数组扩容的
            阈值。
            
            计算位置：
            使用key的hash值与数组长度做与运算
            
            添加节点到链表：
            找到位置后会先对key判重，如果没有重复，就准备将新值放入到链表的表头
            
            数组扩容：
            resize（）方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移
            开始遍历原数组，进行数据迁移。
            如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了
            
            java8的put：
            第一次put的时候回调用resize，类似java7的第一次put也要初始化数组长度，第一次resize和后续
            扩容有些不一样，因为这次是数组从null初始化到默认的16或自定义。
            如果找到具体的数组下标，如果此位置没有值，那么直接初始化一下Node并防止在这个位置可以了
            如果该位置有数据：
            首先判断 该位置的第一个数据和我们要插入的数据key是不是相等，如果是取出这个节点
            如果该节点代表红黑树的节点，调用红黑树的插值方法
            如果插入的位置是一个链表，那么插入的链表的最后面
            如果超出8个，那么会把链表转化为红黑树
            如果在该链表中找到相等的key（==或equals）
            此时break那么e为链表中[与要插入的新值的 key "相等"]的 node
            那么久将新值覆盖旧值，然后返回旧值。
            
            如果HashMap 由于新插入这个值导致size超过了阈值，需要进行扩容
            
            get方法：
            1、计算key的hash值，根据hash值找到对应数组下标 ：hash&(length-1)
            2、判断该数组该位置处，是否就是我们要找的，如果不是，则第三部
            3、判断元素类型是否是TreeNode，如果是，用红黑树的方法获取数据，如果不是走第四部
            4、遍历链表，知道找到相等（==或equals）的key
            
            
            ConcurrentHashMap：
            是J.U.C的重要成员，他是HashMap的一个线程安全的、支持高并发的版本。在默认理想状态
            下，ConcurrentHashMap可以支持16线程执行并发写操作和任意数量线程的读操作。
            ConcurrentHashMap本质上是一个segment数组，而一个segment实例又包含若干个桶，
            每个桶中都包含一条HashEntry对象链接起来的链表。
            总的来说，ConcurrentHashMap的高效并发机制是通过以下三方面来保证的(具体细节见后文阐述)：
            1、通过锁分段技术保证并发环境下写操作
            2、通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作
            3、通过不加锁和加锁两种方案控制跨段操作的安全性
            
            
            
            
            