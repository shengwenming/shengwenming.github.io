---
layout:     post
title:      JAVA面试及题解
subtitle:
date:       2018-08-25
author:     SWM
header-img: img/back.jpg
catalog: true
tags:
    - JAVA
    

---
## 基础篇

### 基本功

####    1、面向对象的特征
    面向对象的三个基本特征是封装、多态和继承。
    
    **封装**就是把事物抽象成类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    
    **继承**可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
    继承实现的三种方式为：实现继承、接口继承和可视继承。
    实现继承是指使用基类的属性和方法而无需额外编码的能力
    接口继承是指仅使用属性和方法名称，但是子类必须提供实现的能力
    可视继承是指子（窗体）类使用基（窗体）类的外观和实现代码的能力。
    
####    2、final、finally、finalize 的区别

    final是修饰符，可以修饰类、成员方法和变量。
    
    修饰类：该类不能被继承
    修饰方法：该方法不能被重写
    修饰变量：该变量是常量
    
    
    finally
    
    是异常处理的一部分，常用于释放资源
    一般来说，finally中的方法一定会被执行。在特殊情况下：在执行finally之前，jvm退出了，
    该方法不能被执行
    
    
    finallize
    
    是Object类的一个方法，用于垃圾回收
    
#### 3、int和Integer的区别

    Integer是int的包装类型，int是基本的数据类型
    Integer变量必须实例化之后才能使用而int不用
    Integer是实际对象的引用，指向此new的Integer对象；int直接存储数据值
    Integer的默认值是null；int的默认值是0
    
#### 4、重载和重写的区别
    重载是让类以统一方式处理不同类型数据的一种手段，他们具有相同的名字，但具有不同参数个数\类型
    1、参数个数、类型、顺序至少有一个不同
    2、不能重载只有返回值不同的方法名
    3、存在于父类和子类、同类中
    
    重写：
    1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载
    2、返回的类型必须一直与被重写的方法返回类型相同，否则不能称其为重写而是重载
    3、访问修饰符的限制一定要大于 被重写方法的访问修饰符（public > protected > default > private ）
    4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
    
#### 5、接口和抽象类的区别

    1、接口和抽象类都不能被直接实例化，如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象
    这个子类继承了这个抽象类的所有抽象方法，如果接口要实例化，那么接口定义的变量指向一个子类对象，这个
    子类必须实现这个接口的所有方法
    
    2、抽象类要被子类继承，接口要被子类实现
    3、接口里面只能对方法进行声明，抽象类可以对方法进行声明也可以对方法进行实现
    4、抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类，接口里面
    的方法也必须全部被实现类实现，如果子类不能实现那么子类必须是抽象类。
    5、接口里面的方法只能声明，不能具体实现。这个说明接口时设计的结果，抽象类是重构的结果
    6、抽象类里面可以没有抽象方法。
    7、如果一个类里面有抽象方法那么这个类一定是抽象类。
    8、抽象类中的方法都要被实现，所以抽象方法不能使静态的static，也不能是private
    9、接口（类）可以继承接口，甚至可以继承多个接口。但类只能继承一个类。
    10、抽象级别从高到低：接口 > 抽象类 > 实现类。
    11、抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。当你关注事物本质的时候，请用抽象类
    当你关注操作的时候，请用接口
    12、抽象类的功能应该是远多于接口，但是定义抽象类的代价比较高。因为高级语言一个类只能继承一个父类，
    即在设计的时候要考虑到所有的这个类的子类共有的属性和方法；但是接口却可以继承多个接口，因此接口你只
    需要将特定的动作方法抽象到这个接口即可。也就是说接口的设计具有更大可扩展性，而抽象类设计必须十分
    谨慎
    
#### 6、说说反射的用途及实现       
    反射机制就是JAVA在运行时的一项自观能力，通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。
    
    JAVA的反射机制的实现要借助于4个类：class 、Constructor、Field、Method
    
    JAVA反射的作用：
    在JAVA运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法，对于任意一个对象可以调用他的
    任意一个方法。
    这种动态获取类的信息以及动态调用对象的方法功能来自于java语言的反射机制
    
    Java反射机制主要提供了以下功能：
    在运行时判断任意一个对象所属的类
    在运行时构造任意一个类对象
    在运行时判断任意一个类所具有的成员变量和方法
    在运行时调用任意一个对象的方法
    
    
#### 7、说说自定义注解的场景及实现  
    跟踪代码的依赖性，实现待提配置文件的功能。比较常见的是Spring等框架中的基于注解配置。还可以生成文档
    常见的@See@param@return等。如@override放在方法签名，如果这个并不是覆盖了超类方法，则编译时就能
    检查出 。
    使用@inteface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成
    细节，在定义注解时，不能继承其他注解接口 
    
    
#### 8、HTTP 请求的 GET 与 POST 方式的区别  
    最直观的语义上的区别GET用于获取数据，POST用于提交数据
    GET的参数有长度限制（受限于URL长度，具体取决于浏览器和服务器），而POST则没有
    
#### 9、    session 与 cookie 区别
    1、session在服务端，cookie在客户端（浏览器）
    2、session默认被存在服务器的一个文件里
    3、session的运行以来session id 而 session id是存在cookie中的，也就是说，如果浏览器禁用了cookie，
    同时session也会失效（但是可通过其他方式实现，比如在URL中传递session id）
    4、session可以放在文件、数据库和内存中都可以
    5、用户验证场合一般会用session
    
    维持一个会话的核心就是客户端的唯一标识即session id


#### 10、session 分布式处理

       session复制：
       在支持session复制的web服务器上，通过修改web服务器的配置，可实现将session同步到其他web服务器
       达到每个web服务器上都保存一致的session
       优点：代码上不需要修改和支持
       缺点：需要依赖支持的web服务器，一旦更换成不支持的web服务器就不能使用了，在数据量很大的情况下，
       不仅占用网络资源，而且会导致延迟
       
       适用场景：只适用于web服务器比较少且session数据量小的情况
       可用场景：开原方案tomcat-redis-session-manager
       
       session粘滞：
       将用户的每次请求都通过某种方法强制分发到某一个web服务器上，只要这个服务器上存储了对应session数据，
       就可以实现会话跟踪
       
       优点：使用简单，没有额外开销
       缺点：一旦某个web服务器重启或宕机相对应的session数据将会丢失，而且需要依赖负载均衡机制
       
       使用场景：对稳定性要求不是很高的业务场景
       
       session集中管理：
       在单独的服务器或服务器集群上使用缓存技术，如Redis存储session数据，集中管理所有的session，所有的web
       服务器都从这个存储介质中存取对应的session，实现session共享
       优点：可靠性高，减少web服务器的资源开销
       缺点：实现上有些复杂，配置较多
       适用场景：web服务器较多，要求高可用的情况
       可用方案：Spring session 也可以自己实现，主要是重写
       
       基于cookie管理：
       这种方式每次发起请求的时候都需要将session数据存到cookie中传递给服务端
       优点：不需要依赖外部存储，不需要额外配置
       缺点：不安全。易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽
       适用场景：数据不重要、不敏感且数据量小
       
####  11、       JDBC 流程

    1、加载Driver类，注册数据库驱动
    2、通过DriverManager，适用URL,用户名，密码建立连接
    3、通过connection，适用sql语句打开statement对象
    4、执行语句将结果返回resultset
    5、对结果进行处理
    6、倒叙释放资源resultset - preparedstatement - connection
    



#### 12、MVC 设计思想
    MVC是软件架构的思想，将一个软件按照模型、视图、控制器进行划分，其中，模型用来封装业务逻辑，视图用来
    表示逻辑，控制器用来协调模型与视图（视图通过控制器来调用模型，模型返回处理结果也要先交给控制器，由
    控制器来选择合适的视图显示处理结果）。
    1、模型：
    业务逻辑包含了业务数据加工与处理以及相应的基础服务
    2、视图:展现模型处理结果，另外，提供相应的操作界面，方便用户使用
    3、控制器：视图发请求给控制器，由控制器来选择相应的模型来处理；模型返回的结果给控制器，由控制器选择
    合适视图
    
    1、使用MVC思想来设计一个软件，最根本的原因是为了实现模型的复用
    2、代码的维护性更好
    3、方便测试
    
    
    使用MVC，会增加代码量，相应的也会增加软件开发的成本，设计难度也会增加
    
    
#### 13、    equals 与 == 的区别

    1、==判断两个变量或者实例是不是指向一个内存空间
    equals是判断两个变脸或者实例所指向的内存空间的值是不是相同
    2、==指向内存地址进行比较，equals是对字符串的内容比较
    3、==指引用是否相同，equals指的是值是否相同
    
### 集合

#### 1、List 和 Set 和 Map 区别
        Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素
        （Elements）。一些collection允许相同元素，而另一些则不行
        所有实现Collection接口的类都必须提供两个标准的构造函数：无参的构造函数用于创建空的Collection
        有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的
        Collection有相同的元素。后一个构造函数允许用户复制一个Collection。
        不论Collection的实际类型如何，他都支持一个iterator（）的方法，该方法返回一个迭代子，使用迭代子
        即可逐一访问Collection的每一个元素。
        
        由Collection接口派生的两个接口是List和Set
        
        List接口：
        List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在
        List中的位置类似于数组下标）来访问List中的元素这类似于Java数组，List允许有相同的元素。
        实现List接口的常用类有LinkedList、ArrayList、Vector、Stack
        
            LinkedList类：实现了List接口，允许Null元素。此外LinkedList提供额外的get、remove、insert
            方法在LinkedList首部或尾部。
            这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。
            注意LinkedList没有同步方法。如果多线程同时访问一个List，必须自己实现访问同步，一种解决
            方法是在创建List时构造一个同步的List：
            List list = Collections.synchronizedList(new LinkedList());
            
            ArrayList类：ArrayList实现了可变大小的数组，它允许所有元素，包括null。ArrayList没有同步
            size、isempty、get、set方法运行时间为常数，但是add方法开销为分摊的常数，添加n各元素的时间
            复杂度为O(n)，其他方法运行时间为线性。
            每个ArrayList实例都有一个容量（Capacity）.即用于存储的数组的大小，这个容量可随着不断添加
            新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素的时候，在插入前可以调用
            ensureCapacity方法来增加ArrayList的容量以提高插入效率。ArrayList也是非同步的。
            
            Vector：Vector非常类似ArrayList,但是Vector是同步的，由Vector创建的Iterator，虽然和ArrayList
            创建的Iterator是同一接口，但是，因为vector是同步的，当一个Vector被创建而且正在被使用，
            另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出
            ConcurrentModificationException，因此必须捕获异常。
            
            Stack类：Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外是的Vector可以被当做
            堆栈所使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，
            search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。
        
        
        Set接口：
        存入set的每个元素必须是唯一的，set不保存重复元素。加入set的元素必须定义equals方法确保对象
        的唯一性。set的元素是无序的。
            HashSet：为快速查找设计的Set，存入HashSet的对象必须定义hashcode。
            TreeSet：保存次序的Set，底层为树结构，使用它可以从set中提取有序的xulie
            LingkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）
            于是在使用迭代器遍历Set时，结果会按插入次序显示。
            
        
        
              
              
        Map：     
            Map是一种映射的数据结构，存储key-value的数据，有put、get、containskey、containsvalue等。
            标准的Java类库中包含了几种不同的Map：HashMap，TreeMap，LinkedHashMap、WeakHashMap、
            IdentityHashMap，它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“
            键“等价的策略不同
            
            
            HashTable：
            HashTable实现Map接口，任何非空（non-null）的对象都可作为key或者value。HashTable是同步的
            （线程安全）
            
            HashMap：
            HashMap实现Map接口，是非同步的，HashMap允许null，即null value和null key。HashSet就是基于
            HashMap，只使用了HashMap的key作为单个元素存储。
            
            HashMap的访问方式是基于Map的最基础的三种方式，HashMap的存储方式为散列表（哈希表），哈希表
            使用数组加链表的组合的方式进行存储。
            put的过程：
            1、插入第一个元素的时候，需要先初始化数组大小
            2、如果key为null会把这个放到table[0]
            3、求key的hash值
            4、获取对应的数组下标
            5、遍历下标处的链表，看是否有重复的key已经存在，如果有，则直接覆盖，put方法返回旧值
            6、不存在重复的key，将此entry添加到链表中
            
            
            数组初始化：
            当第一个元素插入HashMap的时候做一次数组初始化，就是先确定初始的数组大小，并计算数组扩容的
            阈值。
            
            计算位置：
            使用key的hash值与数组长度做与运算
            
            添加节点到链表：
            找到位置后会先对key判重，如果没有重复，就准备将新值放入到链表的表头
            
            数组扩容：
            resize（）方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移
            开始遍历原数组，进行数据迁移。
            如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了
            
            java8的put：
            第一次put的时候回调用resize，类似java7的第一次put也要初始化数组长度，第一次resize和后续
            扩容有些不一样，因为这次是数组从null初始化到默认的16或自定义。
            如果找到具体的数组下标，如果此位置没有值，那么直接初始化一下Node并防止在这个位置可以了
            如果该位置有数据：
            首先判断 该位置的第一个数据和我们要插入的数据key是不是相等，如果是取出这个节点
            如果该节点代表红黑树的节点，调用红黑树的插值方法
            如果插入的位置是一个链表，那么插入的链表的最后面
            如果超出8个，那么会把链表转化为红黑树
            如果在该链表中找到相等的key（==或equals）
            此时break那么e为链表中[与要插入的新值的 key "相等"]的 node
            那么久将新值覆盖旧值，然后返回旧值。
            
            如果HashMap 由于新插入这个值导致size超过了阈值，需要进行扩容
            
            get方法：
            1、计算key的hash值，根据hash值找到对应数组下标 ：hash&(length-1)
            2、判断该数组该位置处，是否就是我们要找的，如果不是，则第三部
            3、判断元素类型是否是TreeNode，如果是，用红黑树的方法获取数据，如果不是走第四部
            4、遍历链表，知道找到相等（==或equals）的key
            
            
            ConcurrentHashMap：
            是J.U.C的重要成员，他是HashMap的一个线程安全的、支持高并发的版本。在默认理想状态
            下，ConcurrentHashMap可以支持16线程执行并发写操作和任意数量线程的读操作。
            ConcurrentHashMap本质上是一个segment数组，而一个segment实例又包含若干个桶，
            每个桶中都包含一条HashEntry对象链接起来的链表。
            总的来说，ConcurrentHashMap的高效并发机制是通过以下三方面来保证的(具体细节见后文阐述)：
            1、通过锁分段技术保证并发环境下写操作
            2、通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作
            3、通过不加锁和加锁两种方案控制跨段操作的安全性
            
            
### 线程

#### 1、创建线程的方式及实现
    1、继承Thread类创建线程类，通过start方法开启新线程
    使用方式：
    1、继承Thread类，并重写该类的run方法
    2、new一个实例，调用start方法启动该线程
    
    start和run方法的区别：start方法开启了一个新线程，使线程处于就绪状态；run方法只是在当前线程执行实例方法
    直接调用run方法并没有开启新的线程。
    
    2、实现Runnable接口
    使用方式：
    1、实现Runnable接口，并重写该类的run方法
    2、new一个实例，将该实例作为Thread 的Target创建Thread对象
    3、调用Thread的start方法
    
    3、实现Callable接口
    使用方式：
    1、创建Callable接口的实现类，并实现Call方法      
    2、创建Callable实现类的实例，并用FutrueTask类来包装该实例
    3、使用FutrueTask实例作为target创建Thread实例
    4、调用Thread实例的start方法
    
    
#### 2、    sleep() 、join（）、yield（）有什么区别
    1、Thread.sleep(long)和Thread.yield()都是Thread类的静态方法，而join是通过线程对象来调用
    2、wait（）、notify（）、notifyAll（）这三个方法都是Object的方法
    它们都是用于多线程对共享数据的读取，所以必须在synchronized语句块内使用者三个方法，synchronized用于保护
    共享数据阻止其他线程对共享数据的存取。但是这样程序就不灵活了，这三个方法就是用来灵活控制
    wait方法使当前线程暂停执行并释放对象锁标志，让其他线程进入synchronized数据块，当前线程被放入对象池中。
    当调用notify方法后，将从对象移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取
    锁标志，如果锁标志等待池中没有线程那么notify将不起作用
    notifyAll则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。
    
    sleep和wait的区别：主要是CPU的运行机制（1、cpu是否继续执行 2、锁是否释放掉）
    cpu为每个线程划分时间片执行，每个时间片都很短，CPU不停的切换不同的线程，它们看似同事执行 的效果
    
    锁如果被占用，那么执行代码片段是同步的，如果锁被释放掉就允许其他线程继续执行此代码块了。
    
    sleep一段时间之后，往往线程会立即执行，可见cpu一直在为线程分配时间片，如果外层有synchronized
    那么锁并没有释放掉，因此sleep CPU继续执行，锁并没有释放掉
    
    wait一般用于锁机制中而sleep不是sleep是线程方法跟锁没有关系，wait、notify、notifyAll是一起使用的
    用于锁机制
    
    肯定是要释放锁的，因为notify并不会立即调起此线程，因此cpu是不会为其分配时间片的，就是wait线程进入等待池
    cpu不分时间片给他，锁释放掉。
    
    1、sleep：Thread类的方法，必须带一个时间参数，会让当前线程休眠进入阻塞状态并释放cpu，提供其他线程运行
    的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获取同步锁。
    
    2、yield 让出CPU调度，Thread类的方法，类似sleep只是不由用户指定暂停时间，并且yield只能让同优先级的线程
    有执行机会。yield只是使当前线程重新回到可执行状态，所以执行yield的线程可能在进入可执行状态后马上又被执行
    调用yield方法只是一个建议，告诉调度器我的工作差不多了，可以让别的有相同优先级的线程使用cpu了，没有任何机制
    保证采纳。
    
    3、wait object类的方法（notify、notifyAll也是），必须放在循环体和同步代码块中，执行该方法的会释放
    锁，进入线程等待池中等待被再次唤醒（notify随即唤醒 notifyAll全部唤醒，线程结束自动唤醒）即放入锁池中竞争锁
    
    4、join 一种特殊的wait 当前线程调用另一个线程的join方法当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止，需要捕获异常
    
    线程的5种状态：
    1、新建 （NEW）新建了一个线程对象
    2、可运行（RUNNABLE）：线程对象创建后。其他线程调用此线程的start方法，该状态的线程位于线程池中，等待被线程调度选中，获取cpu使用权
    3、运行（RUNNING）:可运行状态（RUNNABLE）的线程获取cpu时间片（timeslice），执行程序代码
    4、阻塞（BLOCKED）:阻塞状态是指线程因为某种原因放弃了cpu使用权，也让出了timeslice，暂时停止运行。直到线程进入可运行（RUNNABLE
    ）状态，才有机会再次获取cpu timeslice转到运行状态（running）分三种：
    1、等待阻塞：运行状态的线程执行wait方法，jvm会把该线程放入等待队列中（waiting queue）
    2、同步阻塞：运行状态的线程在获取对象的同步锁时，若该同步锁被别的线程占用，jvm会把该线程放入锁池中（lock pool）
    3、其他阻塞：运行的线程执行sleep 或 join 或i/o 请求，jvm会把线程置为阻塞状态。
    当sleep超时、join等待线程终止或超时、或i/o处理完毕线程重新转入可运行状态。
    
    5、  死亡（DEAD）线程run 、main方法执行结束，或者异常退出了run方法，则该线程结束生命周期，死亡线程不可再次复生
    
    
#### 3、说说 CountDownLatch 原理   
    CountDownLatch是一个同步工具，它主要用线程执行之间的写作，CountDownLatch的作用和Thread.join()
    方法类似，让一些线程阻塞到另一些线程完成一系列的动作之后才被唤醒。在直接创建线程的年代
    java5之前，使用Thread.join(),在线程池出现后，因为线程池中的线程不能直接被引用，所以就必须
    在线程池出现后，因为线程池中的线程不能直接被引用，所以就必须使用CountDownLatch了。
    
    CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞，其他线程调用
    countdown方法会将计数器减一。（调用countdown的线程不会阻塞） ，当计数器变为0的时候，因
    await方法阻塞的线程会被唤醒继续执行。
    
    实现原理：计数器的值有构造函数传入，并用它初始化AQS的state值，当线程调用await方法时会检查state的
    值的是否为0，如果是就直接返回（不会阻塞），如果不是，将表示该节点的线程入列，然后将自身阻塞。
    当其他线程调用countdown方法，计数器会减一，然后判断计数器的值是否为0，当他为零时会唤醒队列
    的第一个节点，由于CountDownLatch使用了AQS的共享模式，所以第一个节点被唤醒后又会唤醒第二个节点，
    以此类推，使得所有因await方法阻塞的线程都能被唤醒而继续执行。
    
    一个CountDownLatch对象，只能使用一次不能重复使用
    
#### 4、说说 CyclicBarrier 原理
    CyclicBarrier的字面意思是可循环使用的屏障，他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）
    时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障
    通过CyclicBarrier的await方法。
    
    CyclicBarrier默认的构造方法时CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个
    线程调用await方法告诉屏障我已到达，然后当前线程被阻塞。
    
    CyclicBarrier还提供了一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction）
    用于在线程到达屏障时，优先执行barrierAction这个runnable对象，方便处理更复杂的业务场景。
    
    实现原理：CyclicBarrier在内部定义了一个Lock对象，每当一个线程调用CyclicBarrier的await方法时，
    将剩余拦截的线程数减一，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待，如果是
    执行barrierAction对象的runnable方法。
    
    然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会一次获取锁、释放锁，接着从await方法返回，
    再从CyclicBarrier的await方法返回。
    
    
    
#### 5、说说 Semaphore 原理
    在java的并发包中，Semaphore表示信号量，Semaphore内部主要通过AQS实现线程的管理，Semaphore
    有两个构造函数，参数permits表示许可数，他最后传递给了AQS的state值，线程运行时首先获得许可，
    如果成功，许可数就减一，线程运行，当前线程运行结束释放许可，许可数就加一，如果许可数为0，则
    获取失败，线程位于AQS的等待队列中，他会被其他释放许可的线程唤醒，在创建Semaphore对象的时候
    还可以指定他的公平性，一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而
    不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平信号量在获取
    许可时首先要检查等待队列中是否已有线程，如果有则入列。
    
#### 6、    说说 Exchanger 原理
    Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于线程间的交换数据，他提供一个
    同步点，在这个同步点两个线程可以交换彼此的数据，这两个线程通过exchange方法交换数据，如果第
    一个线程先执行exchange方法，他会一直等待第二个线程也执行exchange，当两个线程到达同步点时，
    这两个线程就可以交换数据，将本线程生产出来的数据传递给对方，因此使用exchanger的重点是成对
    的线程使用exchange方法，当有一对线程达到了同步点，就会进行数据交换，因此该工具的线程对象
    是成对的。
    exchanger类提供了两个方法，exchange（V x）：用于交换，启动交换并等待另一个线程调用exchange
    ，exchange（V x，long timeout，TimeUnit unit）：用于交换，启动交换并等待另一个线程
    调用exchange，并设置最大等待时间，当等待时间超过timeout便停止等待。
    
    
#### 7、说说 CountDownLatch 与 CyclicBarrier 区别
    CountDownLatch：一个或者多个线程等待其他多个线程完成某件事情之后执行
    CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行
    
    对于CountDownLatch来说，重点是一个线程（多个线程）等待，而其他的N个线程在完成某件事情
    之后可以终止也可以等待。而对于CyclicBarrier。重点是多个线程在任意一个线程没有完成，所有
    线程必须等待。
    
    CountDownLatch是计数器，线程完成一个记录一个，只不过计数器不是递增而是递减，而CyclicBarrier
    更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。
    
#### 8、ThreadLocal 原理分析
    
    每个线程都可以独立修改属于自己的副本而不会互相影响，从而隔离了线程和线程，避免了线程
    访问实例变量发生安全问题。
    1、ThreadLocal只是操作Thread中的ThreadLocalMap对象的集合。
    2、ThreadLocalMap变量属于线程的内部属性，不同的线程拥有完全不同的ThreadLocalMap变量
    3、线程中的ThreadLocalMap变量的值是在ThreadLocal对象进行set或者get操作时创建的。
    4、使用当前线程的ThreadLocalMap的关键在于使用当前的ThreadLocal的实例作为key来
    存储value值。
    5、ThreadLocal模式至少从两个方面完成了数据访问隔离，即纵向隔离（线程与线程之间的
    ThreadLocalMap不同）和横向隔离（不同的ThreadLocal实例之间互相隔离）
    6、一个线程中所有的局部变量其实存储在该线程自己的同一个map属性中
    7、线程死亡时，线程局部变量会自动回收内存。
    8、线程局部变量通过一个entry保存在map中，该entry的key是一个weakrefrence包装的ThreadLocal。
    value为线程局部变量，key到value的映射通过：Thread.threadLocalHashCode&(INITIAL_CAPACITY-1)
    来完成的。
    9、当线程拥有的局部变量超过容量的2/3（没有扩大容量时是10个），会涉及到ThreadLocalMap中的entry回收
    
            
#### 9、讲讲线程池的实现原理
    线程池的相关类：Executor、ExecutorService、AbstractExecutorService、ThreadPoolExecutor
    
    Executor：Executor 接口只有一个 方法，execute，并且需要 传入一个 Runnable 类型的参数。那么它的作用
    自然是 具体的执行参数传入的任务。
    
    
    ExecutorService接口继承了Executor，并且提供了一些其他方法，比如说：
    1、shutdownNow：关闭线程池，返回放入了线程池但是还没开始执行的线程
    2、submit：执行的任务 允许拥有返回值
    3、invokeAll ：运行把任务放进集合中，进行批量的执行，并且能有返回值
    
    这三个方法也可以说是这个接口重点扩展的方法
    
    
    execute 和 submit 区别：
     1、execute 没有返回值，submit有返回值，可以根据任务有无返回值选择对应的方法
     2、submit方便处理异常 。如果任务可能会抛出异常，而且希望外面的调用者能够感知这些异常，
     那么就需要调用submit方法，通过获取Future.get抛出的异常。
     
     
     AbstractExecutorService是一个抽象类，主要完成了submit方法，invokeAll方法的实现，但是其实他的内部
     还是调用了execute方法。
     
     ThreadPoolExecutor 继承了AbstractExecutorService，并且实现了最重要的execute方法，有两个重要的
     成员变量，workers和workqueue，对于workers变量，主要存在了线程对象Worker，Worker实现了Runable接口，
     而对于workQueue变量，主要存放了需要执行的任务，这样其实可以猜到，整个线程池的实现原理应该是workqueue
     中不断的取出需要执行的任务，放在workers中进行处理。
     另外，当线程池中的线程用完之后，多余的任务会等待，利用BlockingQueue的take方法进行处理。
     首先，这里需要先理解两个概念，我们在创建线程池的时候，通常会指定两个变量，一个是maximumPoolSize，另一
     个是corePoolSize。
        对于maximumPoolSize：指的是线程池中最多允许有多少个线程
        对于corePoolSize：指的是线程池中正在运行的线程
        
      在线程池，有这样的设定，我们加入一个任务进行执行
      
        如果现在线程池中正在运行的线程数量大于corePoolSize指定的值而小于maximumPoolSize指定的值，那么就会
        创建一个线程对该任务进行执行，一旦一个线程被创建运行。
        
        如果线程池中的线程数量大于corePoolSize，那么这个任务执行完毕后，该线程会被回收。如果小于corePoolSize
        那么该线程即使空闲，也不会被回收，下个任务过来，那么就使用这个空闲线程。
        
         大致原理如下：
         首先，各自存放线程和任务，其中任务带有阻塞，
         然后再execute方法中，进行addWorker（command，true），也就是创建一个线程把任务放进去执行或者是
         直接把任务放入到任务队列中。
         
         接着如果是addWorker，那么就会new Worker（task）- 调用其中run（）方法，在worker的run方法中调用
         runWorker（this） - 在该方法中就会具体执行我们的任务task.run()，同时这个runworker方法相当于是
         个死循环，正常情况下就会一直取出任务队列中的任务执行，这保证了线程不会销毁。
         
         这也就是为什么线程池可以避免频繁创建线程和销毁带来的性能消耗。
         
####  10、       线程池的几种方式
    1、newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收线程，若无可回收
    则新建线程。
    特点是：1、工作线程的创建数量几乎没有限制（其实也有限制的，数目为Integer.MAX_VALUE）,这样可灵活的往
    线程池中添加线程。
    2、如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定时间（默认为1分钟），则该线程会自动终止，终止后
    如果又提交了新的任务，则线程池重新创建一个工作线程。
    3、在使用CachedThreadPool时，要控制任务的数量，否则，由于大量线程同时运行，很可能会造成系统瘫痪
    
    
    2、newFixedThreadPool：创建一个固定长度的线程池，可控制线程的最大并发数，超出的线程在队列中等待。
    
    3、newScheduledThreadPool：创建一个固定长度的线程池，支持定时周期性任务执行。
    
    4、newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的线程来执行任务，保证所有的任务按照指定顺序
    （FIFO,LIFO,优先级）来执行。
    
####  11、   线程的生命周期
     1、新建状态（NEW）
     2、可运行状态（RUNNABLE）
     3、运行状态（RUNNING）
     4、阻塞状态(BLOCKED)
     5、死亡（DEAD）
     
### 锁机制

#### 1、说说线程安全问题     
    当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替执行，我们的主程序中不需要去做任何的同步
    这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。
    
    
#### 2、    volatile 实现原理
    Java内存模型：
    在并发编程领域中一般都会遇到三个概念：原子性、可见性、有序性。
    原子性：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
    
    在单线程环境下可以认为所有的操作都是原子操作，但多线程环境不同，Java只保证基本数据类型的变量和赋值才是原子性的
    （注：在32位JDK环境下，对64位数据的读取不是原子性操作，如long、double）。要想在多线程环境保证原子性则可以通过
    锁、synchronized来确保。
    
    volatile是无法保证复合操作的原子性的。
    
    可见性：
    
    可见性是指当多个线程访问同一变量时，一个线程改变了这个变量的值其他线程可以立即看到。
    
    Java体统了Volatile来保证可见性。
    
    当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后，他会被立即刷新到主内存中，当其
    他线程读取变量时，他会直接从内存读取。
    
    当然synchronized和锁都可以保证可见性。
    
    有序性：
    
    即程序执行的顺序按照代码的先后顺序执行。
    
    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序他不会影响单线程的运行结果，但是对
    多线程会有影响。
    
    Java提供volatile来保证一定的有序性，
    
    Volatile原理
    
    volatile可以保证县城可见性且提供了一定的有序性，但是无法保证原子性，在JVM底层volatile是采用“内存屏障”实现
    
    1、保证内存可见性，不保证原子性。
    2、禁止指令重排序。
    
    在执行程序时为了提高性能，编译器和处理器常对指令做重排序
    1、编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    2、处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    
    指令重排序对单线程没有什么影响，他不会影响程序的运行结果，但是会影响多线程的正确性，既然指令重排序会影响到
    多线程执行的正确性，那么就要禁止重排序，
    
    happens-before原则保证了程序的有序性，他规定如果两个操作的执行顺序无法从happens-before原则中推导出来
    那么就不能保证有序性，可以随意进行重排序。
    
    1、同一个线程中，前面的操作happens-before后续的操作（单线程内代码按顺序执行，但是在不影响在单线程环境
    执行结果的前提，编译器和处理器可以进行重排序，这是合法的，换一句话说，这一规则是无法保证编译重排和指令
    重排）    
    2、监视器上的解锁操作happens-before其后续的加锁操作。（synchronized规则）
    3、对volatile变量的写操作happens-before后续的读操作（volatile规则）
    4、线程的start（）方法happens-before该线程所有的后续操作（线程启动规则）
    5、线程的所有操作happens-before其他线程在该线程上调用join返回成功后的操作
    6、如果a happens-before b， b happens-before c ，那么a happens-before c（传递性）
    
    观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出
    一个lock前缀指令，lock前缀指令其实相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序
    限制，volatile底层就是通过内存屏障来实现的。
    
    volatile相对于synchronized稍微轻量些，在某些场合可以替代synchronized，但是又不能完全取代，只有在某些场
    合才能使用volatile，必须满足以下两个条件：
    1、对变量的写操作不依赖当前值
    2、改变量没有包含在具体其他变量的不变式中
    
    volatile经常用于两个场景状态标记量、double check
    
#### 3、     synchronize 实现原理
    Java虚拟机中的同步（Synchronization）基于进入和退出管程（Monitor）对象实现，无论是显示同步（有明确的
    Monitorenter）和monitorexit指令，即同步代码块）还是隐式同步都是如此。在java语言中，同步用的最多的地方
    可能是被synchronized修饰的同步方法，同步方法并不是由monitorenter和monitorexit指令实现同步的，而是由
    方法调用指令读取运行时常量池中的方法ACC_SYNCHRONIZED标志来隐式实现，关于这点，稍后详细分析。下面先来
    了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。
    
    理解java对象头与monitor
    
    在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。
    
    实例变量：存放类的属性信息，包括父类的属性信息，如果是数组的实例部分好包括数组长度，这部分内存按4字节对齐。
    
    填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点
    了解即可。
    
    而对于顶部，则是java头对象，他实现synchronized的锁对象的基础，一般而言synchronized使用的锁对象是存储在
    java对象头里的，jvm采用2个字节来存储对象头（如果对象是数组则会分配3个字节，多出来一个字节用于记录长度），
    
    MarkWord在默认情况下存储hashcode、分代年龄、锁标记位等，由于对象头信息与对象自身定义的数据没有关系的额外
    存储成本，因此考虑到JVM的空间效率，MarkWord被设计成为一个非固定的数据结构，以方便存储更多有效的数据，他会
    根据对象本身的状态复用自己的存储空间。
    
    轻量级锁和偏向锁是java 6对synchronized锁进行优化后新增的
    
    重量级锁也就是通常所说的synchronized的对象锁锁标识位为10，其中指针指向的是monitor对象（也称为管理和监
    视器锁）的起始地址，每个对象都存在一个monitor与之关联，对象与其monitor之间的关系存在多种实现方式，如
    monitor可以与对象一起创建销毁或当前线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，他便
    处于锁定状态，在java虚拟机中，monitor是由objectmonitor实现的。Monitor对象存在于每个java对象的对象头中
    （存储指针的指向），synchronized锁便是通过这种方式获取锁的 也就是为什么Java中任意对象可以作为锁的原因
    ，同时也是notify、notifyAll、wait等方法存在于顶级对象Object中的原因。
    
    synchronized代码块底层原理：
    
    同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向指向同步代码块的开始位置
    monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时当前线程试图获取objectref（即对象锁）
    所对应的monitor的持有权，当objectref的monitor的进入计数器为0，那么线程成功取得monitor，并将计数器设置为1，
    取锁成功。如果当线程已经拥有objectref的monitor的持有权，那么他可以重入这个monitor，重入时计数器也会加1，
    倘若其他线程已经拥有objectref的monitor的所有权，那么当前线程将被阻塞，直到正在执行线程执行完毕，即
    monitorexit指令被执行，执行线程释放monitor并设置计数器为0，其他线程将有机会持有monitor。值得注意的是
    编译器将会确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都有执行其对应的monitorexit，
    无论这个方法是正常结束还是异常结束，为了保证方法异常完成时monitorenter和monitorexit指令依然可以正确配对
    执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理的所有异常，他的目的就是用来执行monitorexit
    指令，从字节码中也可以看出多了一个monitorexit指令，他就是异常结束时被执行的释放monitor的指令。
    
    synchronized方法底层原理：
    方法级的同步是隐士，即无需通过字节码指令来控制的，他实现在方法调用和返回操作之中 。JVM可以从方法常量池中的
    方法表结构中的 ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的
    ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor(虚拟机规范中用的是管程一词)，然后
    再执行方法，最后再方法完成（无论是正常完成还是非正常完成）时释放monitor在执行期间执行线程持有了monitor，
    其他任何线程都无法再获取同一个monitor，如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理异常，
    那这个同步方法所持有的monitor将在异常抛到同步方法外时自动释放。
    
    
    java虚拟机对synchronized的优化
    
    锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。随着锁的竞争锁可以从偏向锁升级到轻量级锁再升级到
    重量级锁，但是锁的升级是单向的，也就是说只能从低到高，不会出现锁降级
    
    偏向锁：
    偏向锁是java 6 之后加入的新锁，他是一种加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程
    竞争，而且总是由同一个线程多次获得，因此，为了减少同一个线程获取锁（会涉及到CAS操作，耗时）的代价而引入偏向
    锁，偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时markword的结构变为偏向锁结构，
    当这个线程再次请求锁时，无需任何同步操作，即获取锁的过程。这样就省去了大量有关锁申请的操作，从而也就是提高了
    程序的性能，所以对于锁竞争激烈的场合，偏向锁就失效了，因为这样的场合极有可能每次申请锁的线程都是不同的，因此
    不应该使用偏向锁，得不偿失，另外注意，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
    
    轻量级锁
    倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，他会尝试使用一种称为轻量级锁的优化手段（1.6之后加入），此时
    markword结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步期间内不存在竞争”
    这是经验数据，需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合
    就会导致轻量级锁膨胀为重量级锁。
    
    自旋锁
    
    轻量级锁失败后，虚拟机为了避免线程真实的的在操作系统层面挂起，还会进行一项称为自旋锁的优化手段，这是基于在大
    多数情况下，线程持有锁的时间都不太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的
    切换时需要从用户态转换核心态，这个状态之间的转换需要相对比较长的时间，时间成本较高，因此自旋锁会假设在不久将来
    当前线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是成为自旋的原因），一般不会太久，可能
    50到100个循环，在经过若干次循环后，如果得到锁，就顺利进入临界区，如果还不能获得锁，那就会将线程在操作系统层面
    挂起。这是自旋锁的优化方式，这种方式可以提高效率，最后没办法只能升级为重量级锁。
    
    锁消除
    
    锁消除是虚拟机另外一种优化方式，这种优化更彻底，java虚拟机在jit编译时（可以简单理解为当某段代码即将被第一次执
    行时进行编译，又称即时编译），通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有
    必要的锁，可以节省毫无意义的请求锁时间。
    
    
#### 4、    synchronized与Lock的区别
    1、sychronized是JAVA的关键字，在JVM层面上，Lock是一个接口类。
    2、以获取锁的线程执行完同步代码，释放锁，线程执行异常，jvm会让线程释放锁，Lock在finally中必须释放锁，不然容易造成
    线程死锁。
    3、假设A线程获得锁，B线程等待，如果A线程阻塞，B线程会一直等待。Lock分情况而定，Lock有多个获取锁的方式，可以尝试获
    得锁，线程不需要一直等待。
    4、锁的状态：synchronized无法判断，Lock可以判断
    5、锁类型：synchronized可重入，不可中断，非公平，Lock可重入，可判断，可公平
    6、性能：synchronized少量同步，Lock大量同步
    

#### 5、CAS 乐观锁    
    Java里面进行多线程通信的主要方式是共享内存的方式，共享内存主要关注的点有两点：可见性和有序性。加上复合操作的原子
    性，我们可认为java线程安全问题主要关注三点：可见性、有序性和原子性。
    
    Java内存模型解决了可见性和有序性问题，而锁解决了原子性问题。
    
    锁存在的问题：
    java在jdk1.5之前都是靠synchronized关键字保证同步的这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论
    哪个线程持有共享变量的锁，都采用锁独占的方式访问这些变量，独占锁其实就是一种悲观锁。所以可以说synchronized是悲观
    锁。
    
    悲观锁机制存在以下问题：
    1、在多线程竞争机制下。加锁、释放锁会导致比较多的上下文切换和调度延时引起性能问题。
    
    2、一个线程持有锁会导致其他  所有需要此锁的线程挂起。
    
    3、如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置引起性能风险。
    
    而另一个更加有效地锁就是乐观锁，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作 ，如果因为冲突失败就重试
    ，知道成功为止。
    
    与锁相比volatile变量是一个更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度操作，但是volatile不能
    解决原子性问题，因此当一个变量依赖旧值时就不能使用volatile变量。因此对于同步最终还是要回到锁机制上来。
    
    
    乐观锁其实是一种思想，但对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会
    正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误信息，让用户决定如何去做。
    
    主要两个步骤：
    1、冲突检测
    2、数据更新
    
    其实现方式有一种比较典型的就是CAS（Compare And Sawap）
    
    CAS:
    CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只是其中一个线程能更新变量的值，而其他线程都失败，失败的
    线程并不会被挂起，而是被告知这次竞争中失败,并可以再次尝试。
    
    CAS操作包含三个操作数--内存位置（V）、预期原值（A）和新值（B）。如果内存位置的值与预期的原值想匹配，那么处理器会自动将
    该位置值更新为新值，否则，处理器不做任何操作，无论哪种情况，他都会在CAS指令之前返回该位置的值。（在CAS的一些特殊情况下
    ，将仅返回CAS是否成功而不提取当前值）CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则不要
    更改该位置，只告诉我现在位置的值即可。”这其实和乐观锁的冲突检查和数据更新的原理是一样的。
    
    这里再强调一下，乐观锁是一种思想，CAS是这种思想的一种实现方式。
    
    Java对CAS的支持：
    在Jdk 1.5中新增J.U.C就是建立在CAS之上的，相对于synchronized这种阻塞算法，CAS是非阻塞算法的一种实现，所以J.U.C在性能上
    有了很大的提升。
    
    ABA问题：
    CAS算法实现一个重要的前提是取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化，比如说线程1 
    从内存位置V中取出A，这时候另一个线程2也从内存中取出A，并且线程2进行了一些操作变成了B，然后线程2又将位置V的数据变成A，这时
    候线程1进行CAS操作发现内存中仍是A，尽管这个线程操作成功，但不是代表这个过程是没问题的 。
    
    部分乐观锁通过版本号（version）的方式解决ABA的问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和
    数据的版本号一致就可以执行修改操作，并对版本号执行+1操作。否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现
    ABA问题，因为版本号只会增加不会减少。
    
    Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制，锁机制包含两种乐观锁和悲观锁，悲观锁是独占锁，阻塞锁，乐观锁
    是非独占锁，非阻塞锁，有一种乐观锁的实现方式就是CAS,这种算法在JDK1.5中引入的J.U.C中有广泛的应用，但是值得注意的是这种算法会
    存在ABA问题。
    
    另外CAS还有一个应用，那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的，即使是仅仅修改一个指针所指向的位置，在并
    发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，解
    决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性。
    
#### 6、    乐观锁的业务场景及实现方式
    悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作。每次读取的时候都会加锁，这样会增加大量的锁的开销，降低了系
    统的吞吐量。
    
    乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会加大，为了保证保证数据的一致性，应
    用层需要不断的重新获取数据这样会加大查询操作，降低了系统的吞吐量。
    
    读取频繁使用乐观锁，写入频繁使用悲观锁。
    
    JAVA 1.5 J.U.C的CAS操作实现了乐观锁的思想。为解决ABA问题可以加加入版本号。
    
    
## 核心篇

### 数据存储

#### 1、MySQL 索引使用的注意事项
    1、索引的类型
    普通索引、唯一索引、主键索引、外键索引和组合索引，它们创建索引位置上都是一样的，即在表的一个或多个字段上创建使用。
    
    索引优化：
    1、在经常查询的表字段建立索引
    
    具体创建什么索引，可根据需求来定，如果没有特殊要求，如：是否允许重复，那么就可以创建一普通索引，否则可以创建一个唯一索引，
    如果需要多个索引唯一，那么就创建唯一组合索引即可。
    
    2、在大数据量检索中，尽量使用FULL-TEXT代替LIKE
    使用InnoDB引擎的要升级到mysql5.6
    
    3、维护优化索引碎片
    在建有数据索引的数据表中，每当删除记录数据时，对应记录上的索引标记并未删除，这会产生数据垃圾，也叫碎片，长期以往不做处理的话
    会影像数据的检索效率。
    
    比较好的办法重建索引
    
    4、避免使用聚合函数
    在建有索引的数据表中，尽量在检索条件后不使用聚合函数，这可能会使索引失效，影响数据检索速度。
        
             
####2、说说分库与分表设计
    应用场景：使用mysql数据库做查询，当数据量超过200W时，查询数据受到限制，此时为了避开这一个瓶颈，我们采取分库分表的数据库
    设计思想，将数据按照一定规律保存至数据库，常用方式如下：
    1、使用时间作为依据分库分表
    例如可以将数据按月份保存在表中，例如：translate_2015_01,translate_2015_02.......以此达到分表、分库的目的；
    2、使用数字作为分库分表的标准（取余）
    我们经常会定义某个字段自增长或者某个随机数或者特定编码，利用这个编码，我们将其存放在不同的表中，例如，我们想要定义30张表
    存我们获得的数据，第一个值为1，我们用1%30=1，由此可知该数据放在第一张表中，有例如500%30=20，该数据放入第20张表。
    3、使用MD5区分
    在上传文件过程中，将文件名的MD5值取前3位作为上传文件保存的文件夹名称，这样便将上传的文件保存在了3^3文件夹中方便下次找到该
    文件。
    
####3、    分库与分表带来的分布式困境与应对之策
    1、数据迁移与扩容问题
    水平分表策略可以分为随机分表和连续分表两种情况，连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大
    压力，热数据的表就成为了整个数据库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到，连续分表的另外一个好处在于比较
    容易，不需要考虑迁移旧的数据，需要添加分表就可以自动扩容，随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈，
    但是分表扩展需要迁移旧的数据。
    针对于水平分表的设计至关重要，需要评估中短期业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要
    多少分片，对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。
    
    2、表关联问题
    在单库单表的情况下，联合查询是非常容易的，但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题，这设计
    之初就应该尽量避免联合查询，可以通过程序中进行拼装或者通过反范式设计进行规避。
    
    3、分页与排序问题
    一般情况下，列表分页时需要按照指定的字段进行排序，在单库单表的情况下，分页和排序也是非常容易的，但是随着分库与分表的
    演变，也会遇到跨库排序和跨表排序问题，为了   最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表
    返回的结果进行汇总和再次排序，最后再返回给用户。
    
    4、分布式事务问题
    随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题，目前，分布式事务并
    没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我
    恢复和修正，数据最终达到一致。
    
    5、分布式全局唯一ID
    在单库单表情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单，在分库分表 的环境中，数据分布在不同的表中，
    不能再借助数据库自增长特性，需要使用全局唯一ID，例如UUID、GUID等。
    
    分库分表主要应用于应对海量数据和高并发，然而，分库与分表是一把双刃剑，虽然很好的应对海量数据和高并发对数据库的冲击和
    压力，但是却提高的系统的复杂度和维护成本。需要结合实际需求，不宜过度设计，在项目一开始不采用分库与分表设计，而是随着
    业务的增长，在无法继续优化的情况下，再考虑分库与分表提高系统的性能。
    
    
####4、    说说 SQL 优化之道
    1、负向条件查询都不能用索引
    
    select * from order where status!=0 and stauts!=1
    
    not in/not exists都不是好习惯
    
    可以优化为in查询：
    
    select * from order where status in(2,3)
    
    
    2、前导模糊查询不能使用索引
    select * from order where desc like '%XX'
    
    而非前导模糊查询则可以：
    
    select * from order where desc like 'XX%'
    
    3、数据区分度不大的字段不宜使用索引
    select * from user where sex=1
    
    原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。
    
    经验上，能过滤80%数据时就可以使用索引，对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，
    则应该建立索引。
    
    4、在属性上进行计算不能命中索引
    select * from order where YEAR(date) < = '2017'
    
    即使date上建立了索引，也会全表扫描，可优化为值计算：
    select * from order where date < = CURDATE()
    
    select * from order where date < = '2017-01-01'
    
    5、如果业务大部分使用单条查询，使用Hash索引性能更好，例如用户中心
        
    select * from user where uid=?
    
    select * from user where login_name=?
    
    原因：B-TREE   索引的时间复杂度是O(log（n）)；Hash索引的时间复杂度是O（1）    
    
    6、允许null的列，查询有潜在大坑
    
    单列索引不存null值，复合索引不存全为null值，如果列允许null可能会得到不符合预期的结果集
    select * from user where name != 'shenjian'
    
    如果那么允许为null，索引不存储null值，结果集中不会包含这些记录
    
    所以，请使用not null约束以及默认值
    
    7、复合索引最左前缀，并不是指SQL语句的where顺序要和索引一致
    用户中心建立(login_name, passwd)的复合索引
    select * from user where login_name=? and passwd=?
    
    select * from user where passwd=? and login_name=?
    
    都能够命中索引
    
    select * from user where login_name=?
    
    
    也能命中索引，满足复合索引最左前缀
    

    select * from user where passwd=?
    
    不能命中索引，不满足复合索引最左前缀
    
    8、使用ENUM而不是字符串
    
    ENUM保存的是TINYINT，别在枚举中搞一些“中国”、“北京”这样的字符串，字符串空间又大，效率又低。
    
    9、如果明确知道只有一条返回，limit 1能够提高效率
    
    select * from user where login_name=?
    
    可以优化为：
    
    select * from user where login_name=? limit 1
    
    原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动
    
    10、把计算放到业务层而不是数据库层，除了节省数据的CPU还有意想不到的查询缓存优化效果
    
    select * from order where date < = CURDATE()
    
    $curDate = date('Y-m-d');
    
    $res = mysql_query(
    
        'select * from order where date < = $curDate');
        
     原因：
     
     释放了数据库的CPU
     
     多次调用，传入的SQL相同，才可以利用查询缓存
     
     
     11、强制类型转换会全表扫描
     
     select * from user where phone=13800001234
     
     12、尽量使用数字字段
     
     13、尽可能的使用 varchar/nvarchar 代替 char/nchar
     
     14、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
     
     15、尽量使用表变量代替临时表，如果表变量包含大量数据，请注意索引非常有限（只有主键索引）
     
     16、避免频繁创建和删除临时表
     
     17、临时表并不是不可使用，适当使用他们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时，但
     是对于一次性事件，最好使用导出表。

    
####5、    MySQL 遇到的死锁问题
    死锁是指两个或者两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，此时称系统
    出于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，表级锁不会产生死锁，所以解决死锁主要还是针对于最常用的InnoDB
    
    死锁的关键在于：两个或两个以上的Session加锁的顺序不一致。
    
    那么对应的解决死锁问题的关键是：让不同的Session加锁有次序。
    
    
    设置锁超时时间set lock_timeout：尝试获取锁的时候加一个锁超时时间，如果超过这个时间放弃对该锁请求。比如设置A的超时时间为10ms，B
    为100ms，A试了10ms以后获取不到资源，然后会自动断开，A断开了，这时B就可以获取资源了，避免了死锁。（但这个方法不太好的地方在于，还
    需要对A再次提交，而且timeout的时间需要综合很多其他因素去设置）
    
    对所使用的数据全部加锁：每一个事务一次就将所有要用到的数据全部加锁，否则就不允许执行，比如A在B转钱的时候，会使用到A账户转账前，A转
    账后，B账户转账前，B账户转账后，所以就算是A给B转账，也要把A 、B账户所有信息都一起加锁（这样B想给A转账也不行因为被锁住了，不过这个
    效率很低，可能也会带来其他死锁问题）
    
    设置锁优先级：提前设置优先级，如果运行A和B出现死锁，优先级低的回滚，优先级高的先执行，这样即可解决死锁问题。
    
    
####6、    存储引擎的 InnoDB 与 MyISAM
    MyISAM存储引擎的主要特点是：表级锁、不支持事务和全文索引，适合一些CMS内容管理系统作为后台数据库使用，但是使用大并发、重负荷生产
    系统上，表锁结构的特性就显得力不从心。
    
    InnoDB存储引擎的特点是：行级锁，事务安全（ACID兼容），支持外键、不支持FULLTEXT类型的索引（5.6.4之后开始支持FULLTEXT类型索引）。
    InnoDB是为处理巨大量时拥有最大性能而设计的。他的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。
    
####7、    数据库索引的原理
    索引的目的在于提高查询效率，可以类比字典。通过不断缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，
    就是我们总是通过同一种查找方式来锁定数据。
    
    数据库的情况要复杂很多，不仅面临等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。搜索树的平均复杂度
    为logN，具有不错的查询性能，但是复杂度模型是基于每次相同的操作成本考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每
    次又可以把部分数据读入内存来计算，因为访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足应用场景。
    
    磁盘读取数据量靠的是机械运动，每次读取数据花费的时间可分为寻道时间、旋转延迟、传输时间三个部分。寻道时间指的是磁臂移动到指定磁道所
    需的时间，主流磁盘一般在5ms以下，旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转
    120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略
    不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执
    行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的
    时间，显然是个灾难。
    
    考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址数据，而且吧相邻磁盘地质数据也读取到缓冲区
    内，因为局部预读性原理告诉我们，当计算机访问一个地址数据的时候，与其相邻的数据也会很快被访问到，每一次IO读取的数据我们称之为一页，
    具体一页有多大数据跟操作系统有关，一般为4K或8K，也就是我们读取一页内的数据的时候，实际上才发生了一次IO，这个理论对于索引的数据设计
    结构设计非常有帮助。
    
    1、IO的次数取决于b+树的高度h，假设当前数据表的数据为N，每个磁盘块数据项的数量是m，则有h=log(m+1)N,
    当数据量N一定的情况下，m越大， h越小，而m=磁盘块大小/数据项大小，磁盘块的大小也就是一个数据页的大小
    ，是固定的。如果数据项占的空间越小，数据项的数量就越多，树的高度就越低，这就是为什么每个数据项，
    即索引字段要尽量的小，比如int占4个字节，要比bigint8字节少一半。这也是为什么B+树要求把真是的数据放到
    叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅下降，导致树增高，当数据项等于1时，将
    退化成线性表。
    
    2、当B+树的数据项是复合的数据结构比如（name，age，sex）的时候，B+树是按照从左到右的顺序来建立搜索树
    的，比如当（张三，20，F）这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name
    相同再依次比较age和sex，最后得到检索的数据，但当（20，F）这样没有name的数据的时候，B+树就不知道下一
    步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去
    哪里查询，比如当（张三，F）这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age缺失，
    所以只能把名字等于张三的数据都找到，然后在匹配性别是F的数据，这个是非常重要的性质，即索引的最左匹配
    特性。
    
    
    
    
    
    

    
    

    
